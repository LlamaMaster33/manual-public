<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>arc_foxtrot_manual.pdf</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Computer Modern', 'Latin Modern Roman', 'Times New Roman', serif;
            background-color: #525659;
            overflow-x: hidden;
        }
        .pdf-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: #323639;
            display: flex;
            align-items: center;
            padding: 0 10px;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .toolbar-button {
            background: transparent;
            border: none;
            color: #f0f0f0;
            padding: 6px 12px;
            margin: 0 2px;
            cursor: pointer;
            border-radius: 2px;
            font-size: 13px;
        }
        .toolbar-button:hover {
            background: #474b4f;
        }
        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: #555;
            margin: 0 8px;
        }
        .zoom-controls {
            display: flex;
            align-items: center;
            margin-left: auto;
        }
        .zoom-level {
            color: #f0f0f0;
            margin: 0 10px;
            font-size: 13px;
            min-width: 50px;
            text-align: center;
        }
        .pdf-container {
            margin-top: 50px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .page {
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            margin: 10px 0;
            position: relative;
            width: 8.5in;
            padding: 1in;
            font-size: 12pt;
            line-height: 1.5;
            color: #000;
            transform-origin: top center;
            min-height: 9in;
        }
        .page-header {
            position: absolute;
            top: 0.5in;
            left: 1in;
            right: 1in;
            display: flex;
            justify-content: space-between;
            font-size: 10pt;
            color: #666;
        }
        .page-footer {
            position: absolute;
            bottom: 0.5in;
            right: 1in;
            font-size: 10pt;
            color: #666;
        }
        .title-page {
            text-align: center;
            padding-top: 3in;
        }
        .title-page h1 {
            font-size: 28pt;
            font-weight: bold;
            margin-bottom: 0.3em;
            line-height: 1.3;
        }
        .title-page .version {
            font-size: 18pt;
            margin: 0.5em 0;
        }
        .title-page .subtitle {
            font-size: 14pt;
            margin: 0.5em 0;
        }
        .title-page .author {
            font-size: 14pt;
            margin-top: 2em;
        }
        .distribution-statement {
            text-align: center;
            margin: 2em 0;
            padding: 1em;
        }
        h1.section-title {
            font-size: 20pt;
            font-weight: bold;
            margin: 1em 0 0.8em 0;
        }
        h2.subsection-title {
            font-size: 16pt;
            font-weight: bold;
            margin: 0.8em 0 0.6em 0;
        }
        h3.subsubsection-title {
            font-size: 14pt;
            font-weight: bold;
            margin: 0.6em 0 0.4em 0;
        }
        p {
            margin: 0.5em 0;
            text-align: justify;
            hyphens: auto;
        }
        ul, ol {
            margin: 0.5em 0 0.5em 1.5em;
        }
        li {
            margin: 0.3em 0;
        }
        li > ul, li > ol {
            margin-top: 0.3em;
        }
        strong {
            font-weight: bold;
        }
        em {
            font-style: italic;
        }
        .quote-block {
            text-align: center;
            font-style: italic;
            margin: 1.5em 2em;
            font-size: 13pt;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1em 0;
            font-size: 11pt;
        }
        table th, table td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid #000;
        }
        table th {
            font-weight: bold;
            border-bottom: 2px solid #000;
        }
        table caption {
            margin-top: 0.5em;
            font-size: 10pt;
            text-align: center;
        }
        #loading {
            color: white;
            text-align: center;
            padding: 100px;
            font-size: 18pt;
        }
        @media print {
            body {
                background: white;
            }
            .pdf-toolbar {
                display: none;
            }
            .pdf-container {
                margin-top: 0;
                padding: 0;
            }
            .page {
                box-shadow: none;
                page-break-after: always;
                margin: 0;
            }
        }
    </style>
</head>
<body>
    <div class="pdf-toolbar">
        <button class="toolbar-button" onclick="window.print()" title="Print">üñ®Ô∏è Print</button>
        <button class="toolbar-button" onclick="downloadPDF()" title="Save">üíæ Save</button>
        <div class="toolbar-separator"></div>
        <button class="toolbar-button" onclick="scrollToTop()" title="First Page">‚èÆÔ∏è</button>
        <button class="toolbar-button" onclick="scrollToBottom()" title="Last Page">‚è≠Ô∏è</button>
        <div class="zoom-controls">
            <button class="toolbar-button" onclick="zoomOut()">‚àí</button>
            <span class="zoom-level" id="zoom-level">100%</span>
            <button class="toolbar-button" onclick="zoomIn()">+</button>
        </div>
    </div>

    <div class="pdf-container" id="pdf-container">
        <div id="loading">Loading PDF...</div>
    </div>

    <script>
        let currentZoom = 1.0;

        function zoomIn() {
            currentZoom = Math.min(currentZoom + 0.1, 3.0);
            applyZoom();
        }

        function zoomOut() {
            currentZoom = Math.max(currentZoom - 0.1, 0.5);
            applyZoom();
        }

        function applyZoom() {
            const pages = document.querySelectorAll('.page');
            pages.forEach(page => {
                page.style.transform = `scale(${currentZoom})`;
                page.style.marginBottom = `${10 * currentZoom}px`;
            });
            document.getElementById('zoom-level').textContent = Math.round(currentZoom * 100) + '%';
        }

        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function scrollToBottom() {
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }

        function downloadPDF() {
            alert('To download as PDF:\n\n1. Press Ctrl+P (or Cmd+P on Mac)\n2. Select "Save as PDF"\n3. Click Save\n\nOr compile the .tex file with pdflatex for best results.');
        }

        function cleanLatexText(text) {
            // Remove comments
            text = text.replace(/(?<!\\)%.*$/gm, '');
            
            // Convert LaTeX formatting
            text = text.replace(/\\textbf\{([^}]+)\}/g, '<strong>$1</strong>');
            text = text.replace(/\\textit\{([^}]+)\}/g, '<em>$1</em>');
            text = text.replace(/\\emph\{([^}]+)\}/g, '<em>$1</em>');
            
            // Remove footnotes (convert to inline with *)
            text = text.replace(/\\footnote\{([^}]+)\}/g, ' <sup style="color: #666;">*</sup>');
            
            // Convert quotes
            text = text.replace(/``/g, '"');
            text = text.replace(/''/g, '"');
            
            // Convert dashes
            text = text.replace(/---/g, '‚Äî');
            text = text.replace(/--/g, '‚Äì');
            
            // Convert special characters
            text = text.replace(/\\&/g, '&amp;');
            text = text.replace(/\\\$/g, '$');
            text = text.replace(/\\%/g, '%');
            text = text.replace(/\\_/g, '_');
            text = text.replace(/\\\\/g, '<br>');
            
            // Remove LaTeX spacing commands
            text = text.replace(/\\addcontentsline\{[^}]+\}\{[^}]+\}\{[^}]+\}/g, '');
            text = text.replace(/\\newpage/g, '');
            text = text.replace(/\\vspace\{[^}]+\}/g, '');
            text = text.replace(/\\noindent/g, '');
            text = text.replace(/\\centering/g, '');
            
            // Remove line breaks with spacing
            text = text.replace(/\\\\\[[^\]]+\]/g, '<br>');
            
            return text;
        }

        function processItemize(text) {
            // Process nested lists by iterating multiple times
            let processedText = text;
            let depth = 0;
            let maxDepth = 5; // Prevent infinite loops
            
            // Process from innermost to outermost
            while (depth < maxDepth && /\\begin\{itemize\}[\s\S]*?\\end\{itemize\}/.test(processedText)) {
                processedText = processedText.replace(/\\begin\{itemize\}([\s\S]*?)\\end\{itemize\}/g, (match, content) => {
                    // Check if this contains nested itemize (already processed as HTML)
                    if (content.includes('<ul>')) {
                        // This is an outer list with processed inner lists
                        content = content.replace(/\\item\s+/g, '|ITEM|');
                        const items = content.split('|ITEM|').filter(i => i.trim());
                        return '<ul>' + items.map(item => `<li>${item.trim()}</li>`).join('') + '</ul>';
                    } else {
                        // This is an innermost list
                        content = content.replace(/\\item\s+/g, '|ITEM|');
                        const items = content.split('|ITEM|').filter(i => i.trim());
                        return '<ul>' + items.map(item => `<li>${cleanLatexText(item.trim())}</li>`).join('') + '</ul>';
                    }
                });
                depth++;
            }
            return processedText;
        }

        function processEnumerate(text) {
            // Process nested lists by iterating multiple times
            let processedText = text;
            let depth = 0;
            let maxDepth = 5;
            
            while (depth < maxDepth && /\\begin\{enumerate\}[\s\S]*?\\end\{enumerate\}/.test(processedText)) {
                processedText = processedText.replace(/\\begin\{enumerate\}([\s\S]*?)\\end\{enumerate\}/g, (match, content) => {
                    if (content.includes('<ol>') || content.includes('<ul>')) {
                        // This is an outer list with processed inner lists
                        content = content.replace(/\\item\s+/g, '|ITEM|');
                        const items = content.split('|ITEM|').filter(i => i.trim());
                        return '<ol>' + items.map(item => `<li>${item.trim()}</li>`).join('') + '</ol>';
                    } else {
                        // This is an innermost list
                        content = content.replace(/\\item\s+/g, '|ITEM|');
                        const items = content.split('|ITEM|').filter(i => i.trim());
                        return '<ol>' + items.map(item => `<li>${cleanLatexText(item.trim())}</li>`).join('') + '</ol>';
                    }
                });
                depth++;
            }
            return processedText;
        }

        function processDescription(text) {
            return text.replace(/\\begin\{description\}([\s\S]*?)\\end\{description\}/g, (match, content) => {
                // Match \item[term] definition pattern
                const items = [];
                const itemRegex = /\\item\[([^\]]+)\]\s*([^\\]*?)(?=\\item\[|$)/g;
                let itemMatch;
                
                while ((itemMatch = itemRegex.exec(content)) !== null) {
                    const term = itemMatch[1];
                    const definition = itemMatch[2].trim();
                    items.push({ term, definition });
                }
                
                if (items.length === 0) return match;
                
                let html = '<dl style="margin: 1em 0;">';
                items.forEach(item => {
                    html += `<dt style="font-weight: bold; margin-top: 0.5em;">${cleanLatexText(item.term)}</dt>`;
                    html += `<dd style="margin-left: 2em; margin-bottom: 0.5em;">${cleanLatexText(item.definition)}</dd>`;
                });
                html += '</dl>';
                return html;
            });
        }

        function processTable(text) {
            return text.replace(/\\begin\{table\}[\s\S]*?\\begin\{tabular\}\{[^}]+\}([\s\S]*?)\\end\{tabular\}[\s\S]*?(?:\\caption\{([^}]+)\})?[\s\S]*?\\end\{table\}/g, (match, content, caption) => {
                const rows = content.split('\\\\').filter(r => r.trim() && !r.includes('\\toprule') && !r.includes('\\midrule') && !r.includes('\\bottomrule'));
                let html = '<table>';
                
                rows.forEach((row, idx) => {
                    const cells = row.split('&').map(c => c.trim());
                    if (idx === 0) {
                        html += '<tr>' + cells.map(c => `<th>${cleanLatexText(c)}</th>`).join('') + '</tr>';
                    } else {
                        html += '<tr>' + cells.map(c => `<td>${cleanLatexText(c)}</td>`).join('') + '</tr>';
                    }
                });
                
                html += '</table>';
                if (caption) {
                    html += `<div style="text-align: center; margin-top: 0.5em; font-size: 10pt;">${cleanLatexText(caption)}</div>`;
                }
                return html;
            });
        }

        function processContent(text) {
            // Process center environment
            text = text.replace(/\\begin\{center\}([\s\S]*?)\\end\{center\}/g, (match, content) => {
                return `<div style="text-align: center; margin: 1em 0;">${cleanLatexText(content.trim())}</div>`;
            });
            
            // Process lists (handles nesting internally)
            text = processItemize(text);
            text = processEnumerate(text);
            text = processDescription(text);
            
            // Process tables
            text = processTable(text);
            
            // Clean remaining text
            text = cleanLatexText(text);
            
            // Remove remaining LaTeX commands (including starred versions)
            text = text.replace(/\\[a-zA-Z]+\*?(\[[^\]]*\])?(\{[^}]*\})?/g, '');
            
            // Split into paragraphs
            const parts = text.split(/\n\s*\n/);
            let html = '';
            
            parts.forEach(part => {
                part = part.trim();
                if (!part) return;
                
                // If it's already HTML (contains tags), add as-is
                if (part.includes('<ul>') || part.includes('<ol>') || part.includes('<table>') || part.includes('<dl>') || part.includes('<div')) {
                    html += part;
                } else {
                    // It's a paragraph
                    html += `<p>${part}</p>`;
                }
            });
            
            return html;
        }

        function createPage(content, pageNum, hasHeader = true) {
            const page = document.createElement('div');
            page.className = 'page';
            
            if (hasHeader && pageNum > 1) {
                const header = document.createElement('div');
                header.className = 'page-header';
                header.innerHTML = `<span>Version 1.0.5</span><span>Arc Foxtrot Conditioning Program</span>`;
                page.appendChild(header);
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.innerHTML = content;
            page.appendChild(contentDiv);
            
            if (pageNum > 0) {
                const footer = document.createElement('div');
                footer.className = 'page-footer';
                footer.textContent = `Page ${pageNum}`;
                page.appendChild(footer);
            }
            
            return page;
        }

        async function loadDocument() {
            try {
                const response = await fetch('arc_foxtrot_manual.tex');
                const latex = await response.text();
                
                const container = document.getElementById('pdf-container');
                container.innerHTML = '';
                
                // Extract document content
                let content = latex.substring(latex.indexOf('\\begin{document}') + 16, latex.lastIndexOf('\\end{document}'));
                
                // Create title page
                const titlePage = createPage(`
                    <div class="title-page">
                        <h1>Arc Foxtrot Conditioning Program Manual</h1>
                        <p class="version">Version 1.0.5</p>
                        <p class="subtitle">Professional Military-Grade Combatives and Tactical Training</p>
                        <p class="author"><strong>Arc Foxtrot Training Academy</strong></p>
                        <p style="margin-top: 3em;">${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                    </div>
                `, 0, false);
                container.appendChild(titlePage);
                
                let pageNum = 1;
                
                // Split content into sections (both \section and \section*)
                const sectionRegex = /\\section\*?\{([^}]+)\}/g;
                const sections = [];
                let lastIndex = 0;
                let match;
                let matchPositions = [];
                
                // Collect all section positions
                while ((match = sectionRegex.exec(content)) !== null) {
                    matchPositions.push({
                        index: match.index,
                        title: match[1],
                        fullMatch: match[0],
                        isStarred: match[0].includes('section*')
                    });
                }
                
                // Create sections from positions
                for (let i = 0; i < matchPositions.length; i++) {
                    const current = matchPositions[i];
                    const next = matchPositions[i + 1];
                    const end = next ? next.index : content.length;
                    
                    sections.push({
                        title: current.title,
                        isStarred: current.isStarred,
                        content: content.substring(current.index, end)
                    });
                }
                
                // Process each section
                sections.forEach(section => {
                    let sectionContent = section.content;
                    const sectionTitle = section.title;
                    
                    // Remove the section command itself
                    sectionContent = sectionContent.replace(/\\section\*?\{[^}]+\}/, '');
                    
                    let pageContent = `<h1 class="section-title">${sectionTitle}</h1>`;
                    
                    // Split by subsections (both regular and starred)
                    const subsectionRegex = /\\subsection\*?\{([^}]+)\}/g;
                    const subsections = [];
                    let subMatchPositions = [];
                    let subMatch;
                    
                    // Collect all subsection positions
                    while ((subMatch = subsectionRegex.exec(sectionContent)) !== null) {
                        subMatchPositions.push({
                            index: subMatch.index,
                            title: subMatch[1],
                            isStarred: subMatch[0].includes('subsection*')
                        });
                    }
                    
                    // Create subsections from positions
                    for (let i = 0; i < subMatchPositions.length; i++) {
                        const current = subMatchPositions[i];
                        const next = subMatchPositions[i + 1];
                        const end = next ? next.index : sectionContent.length;
                        
                        subsections.push({
                            title: current.title,
                            content: sectionContent.substring(current.index, end)
                        });
                    }
                    
                    // If no subsections, process entire section
                    if (subsections.length === 0 && sectionContent.trim()) {
                        pageContent += processContent(sectionContent);
                    }
                    
                    // Process subsections
                    subsections.forEach(subsection => {
                        let subContent = subsection.content;
                        const subTitle = subsection.title;
                        
                        // Remove the subsection command
                        subContent = subContent.replace(/\\subsection\*?\{[^}]+\}/, '');
                        
                        pageContent += `<h2 class="subsection-title">${subTitle}</h2>`;
                        
                        // Split by subsubsections
                        const subsubRegex = /\\subsubsection\{([^}]+)\}/g;
                        const subsubsections = [];
                        let subsubMatchPositions = [];
                        let subsubMatch;
                        
                        // Collect all subsubsection positions
                        while ((subsubMatch = subsubRegex.exec(subContent)) !== null) {
                            subsubMatchPositions.push({
                                index: subsubMatch.index,
                                title: subsubMatch[1]
                            });
                        }
                        
                        // Create subsubsections from positions
                        for (let i = 0; i < subsubMatchPositions.length; i++) {
                            const current = subsubMatchPositions[i];
                            const next = subsubMatchPositions[i + 1];
                            const end = next ? next.index : subContent.length;
                            
                            subsubsections.push({
                                title: current.title,
                                content: subContent.substring(current.index, end)
                            });
                        }
                        
                        // If no subsubsections, process entire subsection
                        if (subsubsections.length === 0 && subContent.trim()) {
                            pageContent += processContent(subContent);
                        }
                        
                        // Process subsubsections
                        subsubsections.forEach(subsubsection => {
                            let subsubContent = subsubsection.content;
                            const subsubTitle = subsubsection.title;
                            
                            // Remove the subsubsection command
                            subsubContent = subsubContent.replace(/\\subsubsection\{[^}]+\}/, '');
                            
                            pageContent += `<h3 class="subsubsection-title">${subsubTitle}</h3>`;
                            pageContent += processContent(subsubContent);
                        });
                    });
                    
                    const page = createPage(pageContent, pageNum);
                    container.appendChild(page);
                    pageNum++;
                });
                
            } catch (error) {
                document.getElementById('pdf-container').innerHTML = `
                    <div class="page">
                        <h2 style="color: #c00;">Error Loading Document</h2>
                        <p>${error.message}</p>
                        <p style="margin-top: 2em;">Make sure you're viewing this from a web server.</p>
                        <p>Start a server with: <code>python3 -m http.server 8000</code></p>
                    </div>
                `;
            }
        }

        window.onload = loadDocument;
    </script>
</body>
</html>
